<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<# // NOTE - Reference your NuGet packages for Rainbow and RainbowCodeGeneration here #>
<#@ assembly name="$(SolutionDir)packages\Rainbow.Core.1.4.1\lib\net452\Rainbow.dll" #>
<#@ assembly name="$(SolutionDir)packages\Rainbow.Storage.Yaml.1.4.1\lib\net452\Rainbow.Storage.Yaml.dll" #>
<#@ assembly name="$(SolutionDir)packages\RainbowCodeGeneration.0.2.0\lib\net452\RainbowCodeGeneration.dll" #>
<# // NOTE - Reference your Sitecore.Kernel.dll and Sitecore.Logging.dll here #>
<#@ assembly name="$(SolutionDir)packages\Sitecore.Kernel.NoReferences.8.2.170407\lib\net452\Sitecore.Kernel.dll" #>
<#@ assembly name="$(SolutionDir)packages\Sitecore.Logging.NoReferences.8.2.170407\lib\net452\Sitecore.Logging.dll" #>
<# 
// CONFIGURATION
var physicalFileStore = @"..\..\..\..\unicorn\Foundation\ORM"; // the path to your serialisation items
var treeName = "Foundation.ORM.Templates"; // the name of the configuration you want to code-generate 
var treePath = "/sitecore/templates/Helix.Skeleton/Foundation/ORM"; // the matching path in Sitecore for the configuration

var Tool = "RainbowCodeGeneration";
var ToolVersion = "1.0";
var templates = RainbowCodeGeneration.RainbowReader.GetTemplates(Host.ResolvePath(physicalFileStore), treeName, treePath);
#>
<#@ import namespace="RainbowCodeGeneration" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated based on the Unicorn serialisation items
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
// ReSharper disable InconsistentNaming
namespace Helix.Skeleton.Foundation.ORM
{
	using global::Sitecore.Data;

	[global::System.CodeDom.Compiler.GeneratedCodeAttribute("<#=Tool#>", "<#=ToolVersion#>")]
    public struct SitecoreTemplates
    {
	<# foreach (var template in templates) { #>

		/// <summary>
		/// <#= template.Item.Name #>
		/// <para><#= template.Item.GetSharedField("__Short description") #></para>
		/// <para>Path: <#= template.Item.Path #></para>	
		/// <para>ID: <#= template.Item.Id #></para>	
		/// </summary>
		[global::System.CodeDom.Compiler.GeneratedCodeAttribute("<#=Tool#>", "<#=ToolVersion#>")]
		public struct <#= StringExtensions.AsClassName(template.Item.Name) #>
        {
			/// <summary>
			/// The ID for <#= template.Item.Path #>
			/// </summary>
			[global::System.CodeDom.Compiler.GeneratedCodeAttribute("<#=Tool#>", "<#=ToolVersion#>")]
            public static ID Id = new ID("{<#= template.Item.Id #>}");
			/// <summary>
			/// The TemplateId string for <#= template.Item.Path #>
			/// </summary>
			[global::System.CodeDom.Compiler.GeneratedCodeAttribute("<#=Tool#>", "<#=ToolVersion#>")]
			public const string TemplateId = "<#= template.Item.Id #>";
<# foreach (var field in template.Fields) { #>

			public struct <#= StringExtensions.AsClassName(field.Name) #>
            {
				/// <summary>
				/// The <#=field.Name#> field.
				/// <para><#= field.GetSharedField("__Short description")#></para>
				/// <para>Field Type: <#= field.GetSharedField("Type")#></para>		
				/// </summary>
                public const string FieldName = "<#= field.Name #>";

				/// <summary>
				/// The ID for <#=field.Name#> field 
				/// </summary>
                public static ID FieldId = new ID("{<#= field.Id #>}");
            }
<#  } // foreach field #>
		}
<#  } // foreach template #>
	}
}
